{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Graphery Documentations Introduction This is the documentation of how to use Graphery. If you are a writer, please check out For Writers section. If you are a visitor, please check out User Manual section. Feel free to ask any question on GitHub","title":"Home"},{"location":"#welcome-to-graphery-documentations","text":"","title":"Welcome to Graphery Documentations"},{"location":"#introduction","text":"This is the documentation of how to use Graphery. If you are a writer, please check out For Writers section. If you are a visitor, please check out User Manual section. Feel free to ask any question on GitHub","title":"Introduction"},{"location":"about/","text":"About Coming Soon~","title":"About"},{"location":"about/#about","text":"Coming Soon~","title":"About"},{"location":"backend-docs/api-specification/","text":"API Specifications Coming Soon~","title":"APIs"},{"location":"backend-docs/api-specification/#api-specifications","text":"Coming Soon~","title":"API Specifications"},{"location":"backend-docs/cli-usages/","text":"Deprecated","title":"CLI Usages"},{"location":"backend-docs/database-specification/","text":"Introduction The document talks about the database schema and how things are connected. I will list all the fields in each model (table/object), and talk about the relationships it has with other model. I use Django ORM for the database accessing/writing. Some notations: FK : Foreign Key, MTM : Many To Many Relationship, OTO : One To One Relationship. Mixins I copied a description of mixins, but you can just skip it knowing that mixin is just a plugin enabling models having the mixin possess the same properties the mixin has. \"In same cases different models could have same fields and same procedures in the product life cycle. To handle these similarities without having code repetition inheritance could be used. Instead of inheriting a whole class, mixin design pattern offers us to inherit (or some says include) some methods and attributes.\" UUIDMixin id : The unique identifier of records. The value is generated by uuid.uuid4 method in the native Python library. TimeDateMixin created_time : It automatically records the time at which a record is created. modified_time : It automatically records the time at which a record is modified. PublishedMixin is_published : A field indicating whether the record having this property should be displayed publicly. User UUIDMixin username : The username of a user email : The email of a user is_verified : A field indicating whether this user passes email verification role : The role of this user, it can be either one of the following values: Administrator , Author , Translator , Visitor . date_joined : The date on which this user is created Category UUIDMixin PublishedMixin category : The category name Tutorial UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access this tutorial by typing https://domain-name.com/tutorial/url in the browser to access this tutorial name : The unique human readable id of this tutorial categories (MTM): This field links Tutorial with the Category Graph UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access the playground of this graph by typing https://domain-name.com/graph/url (format to be changed in future releases). name : The unique human readable id of this graph categories (MTM): This field links Graph with the Category authors (MTM): This field links Graph with User priority : The priority of this graph, it can be either one of the following values: Main Graph , Supplement Graph , and Trivial Graph tutorials (MTM): This field links Graph with Tutorial Code UUIDMixin TimeDateMixin tutorial (OTO): This field links Code with Tutorial code : The actual content of the Python code ExecResultJson UUIDMixin TimeDateMixin code (FK): This field links ExecResultJson with Code graph (FK): This field links ExecResultJson with Graph json : The actual json content read by the frontend to update Cytoscape graphs and the editor highlighting. {LanguageCode} {LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. authors : This link translations with User , stores the users who wrote/translate this tutorial. tutorila_anchor (OTO): This links translations with Tutorial . abstract : The content of the abstract that will be displayed on the website's abstract section. content_md : The markdown version of the tutorial text content_html : The html version of the tutorial text {LanguageCode}GraphContent {LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. This kind of tables store the info of graphs in different translations. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. abstract : The content of a short introduction of the graph graph_anchor : This link translations of graph content with Graph .","title":"Databse Schema"},{"location":"backend-docs/database-specification/#introduction","text":"The document talks about the database schema and how things are connected. I will list all the fields in each model (table/object), and talk about the relationships it has with other model. I use Django ORM for the database accessing/writing. Some notations: FK : Foreign Key, MTM : Many To Many Relationship, OTO : One To One Relationship.","title":"Introduction"},{"location":"backend-docs/database-specification/#mixins","text":"I copied a description of mixins, but you can just skip it knowing that mixin is just a plugin enabling models having the mixin possess the same properties the mixin has. \"In same cases different models could have same fields and same procedures in the product life cycle. To handle these similarities without having code repetition inheritance could be used. Instead of inheriting a whole class, mixin design pattern offers us to inherit (or some says include) some methods and attributes.\" UUIDMixin id : The unique identifier of records. The value is generated by uuid.uuid4 method in the native Python library. TimeDateMixin created_time : It automatically records the time at which a record is created. modified_time : It automatically records the time at which a record is modified. PublishedMixin is_published : A field indicating whether the record having this property should be displayed publicly.","title":"Mixins"},{"location":"backend-docs/database-specification/#user","text":"UUIDMixin username : The username of a user email : The email of a user is_verified : A field indicating whether this user passes email verification role : The role of this user, it can be either one of the following values: Administrator , Author , Translator , Visitor . date_joined : The date on which this user is created","title":"User"},{"location":"backend-docs/database-specification/#category","text":"UUIDMixin PublishedMixin category : The category name","title":"Category"},{"location":"backend-docs/database-specification/#tutorial","text":"UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access this tutorial by typing https://domain-name.com/tutorial/url in the browser to access this tutorial name : The unique human readable id of this tutorial categories (MTM): This field links Tutorial with the Category","title":"Tutorial"},{"location":"backend-docs/database-specification/#graph","text":"UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access the playground of this graph by typing https://domain-name.com/graph/url (format to be changed in future releases). name : The unique human readable id of this graph categories (MTM): This field links Graph with the Category authors (MTM): This field links Graph with User priority : The priority of this graph, it can be either one of the following values: Main Graph , Supplement Graph , and Trivial Graph tutorials (MTM): This field links Graph with Tutorial","title":"Graph"},{"location":"backend-docs/database-specification/#code","text":"UUIDMixin TimeDateMixin tutorial (OTO): This field links Code with Tutorial code : The actual content of the Python code","title":"Code"},{"location":"backend-docs/database-specification/#execresultjson","text":"UUIDMixin TimeDateMixin code (FK): This field links ExecResultJson with Code graph (FK): This field links ExecResultJson with Graph json : The actual json content read by the frontend to update Cytoscape graphs and the editor highlighting.","title":"ExecResultJson"},{"location":"backend-docs/database-specification/#languagecode","text":"{LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. authors : This link translations with User , stores the users who wrote/translate this tutorial. tutorila_anchor (OTO): This links translations with Tutorial . abstract : The content of the abstract that will be displayed on the website's abstract section. content_md : The markdown version of the tutorial text content_html : The html version of the tutorial text","title":"{LanguageCode}"},{"location":"backend-docs/database-specification/#languagecodegraphcontent","text":"{LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. This kind of tables store the info of graphs in different translations. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. abstract : The content of a short introduction of the graph graph_anchor : This link translations of graph content with Graph .","title":"{LanguageCode}GraphContent"},{"location":"backend-docs/naming-convention/","text":"Naming Convention Deprecated. CLI Reader Folder The folder structure should be structured as following: . \u2514\u2500\u2500 One Tutorial \u251c\u2500\u2500 code \u2502 \u251c\u2500\u2500 entry.py \u2502 \u251c\u2500\u2500 graph-info.json \u2502 \u251c\u2500\u2500 other_modules.py \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 graphs \u2502 \u251c\u2500\u2500 graph1.json \u2502 \u251c\u2500\u2500 graph2.json \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 locale \u251c\u2500\u2500 statics \u2502 \u251c\u2500\u2500 example.jpg \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 title.en-us.md \u251c\u2500\u2500 title.zh-cn.md \u2514\u2500\u2500 ... The Root_Foler contains everything that's need to generate a tutorial page. The resources are divided into three parts: code, graphs, and locale. We will go through them one by one. code Folder The code folder contains all the python code required by this tutorial. Multiple-module/file management is not supported yet. So right now, all the code should be written in one file, the entry.py file. The CLI will detect entry.py file and import the code in it. In side entry.py file, there must be a main function, that is def main (): # do something The function has no arguments and returns None . The CLI will look for main and use it to start the program. Therefore, you can add other functions in entry.py and make sure you reference it directly or indirectly from main . We have a sight module located in bundle.sight , from which you can import tracer . tracer can be used as a function decorator and it traces the variable changes inside of the function. For more usages on tracer , check out the README.md file and the ADVANCED_USAGE.md file in the GitHub repo. If you want to use graph objects in the code, make sure the graph is already registered in the database. To reference a registered graph, you can use graph-info.json . There are two fields in the file, required_graphs and from_tutorials . Both of them must be list of strings of url (to be changed in the future) pointing to the graph object. To use the graph in the code, you must import the graph_object variable under bundle.utils.dummy_graph module. You should use it instead of creating your own graph object, since the CLI will swap the value of graph_object with actual graph objects stated in graph-info.json . graphs Folder The graph folder contains the jsons of the graphs you want to upload to the database. They must follow cyjs format. More about cyjs, please check out this link (the second example in that section). The name of the graph json file will be used as the name of the graph, which is a unique identified in the database. The url of the graph will simply be name with every <space> replaced by - . However, you can change them in the CLI to any strings you want. Additionally, every graph has a short abstract and a human readable title. Each translation of a description should be stored in a Markdown file whose file name follows the Markdown file naming convention below. In addition to the conventions below, the graph abstract should only have one paragraph, that is, one line of content in the markdown file. The extra lines will be omitted. locale Folder The locale folder contains the actual content of the tutorials. Each translation of the actual content should be stored in a Markdown file, whose file name also follows the Markdown file naming convention. The abstract of the content in that translation will be the fist paragraph of the actual content. You can modify it in the CLI or in the admin page. The statics folder under the locale folder should contain any static objects used in the Markdown translation, like images for example. The static resources must use relative path which starts with ./ . Markdown File Convention The Markdown file should be named in title.language_code.md . The title will be the default title prompted by CLI. You can of course modify it. The language code should be the code of the following supported language: en-us zh-cn Note that even English is counted as a translation. So you cannot omit the language code of an English MD file. The Markdown file may have one and only one <h1> tag, which is # in Markdown format. It will be removed during processing and will be the default title prompted by CLI.","title":"Naming Conventions"},{"location":"backend-docs/naming-convention/#naming-convention","text":"Deprecated.","title":"Naming Convention"},{"location":"backend-docs/naming-convention/#cli-reader-folder","text":"The folder structure should be structured as following: . \u2514\u2500\u2500 One Tutorial \u251c\u2500\u2500 code \u2502 \u251c\u2500\u2500 entry.py \u2502 \u251c\u2500\u2500 graph-info.json \u2502 \u251c\u2500\u2500 other_modules.py \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 graphs \u2502 \u251c\u2500\u2500 graph1.json \u2502 \u251c\u2500\u2500 graph2.json \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 locale \u251c\u2500\u2500 statics \u2502 \u251c\u2500\u2500 example.jpg \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 title.en-us.md \u251c\u2500\u2500 title.zh-cn.md \u2514\u2500\u2500 ... The Root_Foler contains everything that's need to generate a tutorial page. The resources are divided into three parts: code, graphs, and locale. We will go through them one by one.","title":"CLI Reader Folder"},{"location":"backend-docs/naming-convention/#code-folder","text":"The code folder contains all the python code required by this tutorial. Multiple-module/file management is not supported yet. So right now, all the code should be written in one file, the entry.py file. The CLI will detect entry.py file and import the code in it. In side entry.py file, there must be a main function, that is def main (): # do something The function has no arguments and returns None . The CLI will look for main and use it to start the program. Therefore, you can add other functions in entry.py and make sure you reference it directly or indirectly from main . We have a sight module located in bundle.sight , from which you can import tracer . tracer can be used as a function decorator and it traces the variable changes inside of the function. For more usages on tracer , check out the README.md file and the ADVANCED_USAGE.md file in the GitHub repo. If you want to use graph objects in the code, make sure the graph is already registered in the database. To reference a registered graph, you can use graph-info.json . There are two fields in the file, required_graphs and from_tutorials . Both of them must be list of strings of url (to be changed in the future) pointing to the graph object. To use the graph in the code, you must import the graph_object variable under bundle.utils.dummy_graph module. You should use it instead of creating your own graph object, since the CLI will swap the value of graph_object with actual graph objects stated in graph-info.json .","title":"code Folder"},{"location":"backend-docs/naming-convention/#graphs-folder","text":"The graph folder contains the jsons of the graphs you want to upload to the database. They must follow cyjs format. More about cyjs, please check out this link (the second example in that section). The name of the graph json file will be used as the name of the graph, which is a unique identified in the database. The url of the graph will simply be name with every <space> replaced by - . However, you can change them in the CLI to any strings you want. Additionally, every graph has a short abstract and a human readable title. Each translation of a description should be stored in a Markdown file whose file name follows the Markdown file naming convention below. In addition to the conventions below, the graph abstract should only have one paragraph, that is, one line of content in the markdown file. The extra lines will be omitted.","title":"graphs Folder"},{"location":"backend-docs/naming-convention/#locale-folder","text":"The locale folder contains the actual content of the tutorials. Each translation of the actual content should be stored in a Markdown file, whose file name also follows the Markdown file naming convention. The abstract of the content in that translation will be the fist paragraph of the actual content. You can modify it in the CLI or in the admin page. The statics folder under the locale folder should contain any static objects used in the Markdown translation, like images for example. The static resources must use relative path which starts with ./ .","title":"locale Folder"},{"location":"backend-docs/naming-convention/#markdown-file-convention","text":"The Markdown file should be named in title.language_code.md . The title will be the default title prompted by CLI. You can of course modify it. The language code should be the code of the following supported language: en-us zh-cn Note that even English is counted as a translation. So you cannot omit the language code of an English MD file. The Markdown file may have one and only one <h1> tag, which is # in Markdown format. It will be removed during processing and will be the default title prompted by CLI.","title":"Markdown File Convention"},{"location":"for-writers/get-started/","text":"Get Started For Writers Introduction This is a guide for people who want to contribute tutorials. Components A tutorial consists of the following components: categories, a tutorial anchor, tutorial content in different languages, a graph anchor, graph info in different languages, code content, and execution results. Add, Delete, and Modify Every component can be created in the control panel. Simply by directing to the component page and clicking on Add New button, the app will take you to a empty page where you can fill in content and save it to the cloud. To delete an entry, click on the red trashcan button at the end of the table, confirm that you know what you are doing in a popup, and the entry should be removed from the database. All deletion is NOT reversible for now. So please be cautious about the delete buttons. Deleting uploads is an exception. You need to click on the upload you want to delete. And you can find the a Delete PERMANENTLY button on a popup. Deleting tutorial anchors and graphs is another exception, which will be described in the following sections. To modify an existing entry, click on the fist cell corresponding to the entry you want to delete, the app will take you to an editing page. Changes are saved only by clicking on the Submit buttons. A green popup will follow every successful save. If you don't see one, there is a chance the content is not saved. Please save the content locally on your computer and contact me if you encounter this situation. Every unsaved changes will be discarded when you leave the page. There will be a confirm popup so don't worry about hitting go back button by accident. About the structure of the control panel Every thing on the control panel table is NOT editable. You have use corresponding editor page to edit content. Every action that involves with the server (or database) will return a status popup, usually on the bottom of the window. If you did something and nothing happened on the page, that means there are some glitches on the server. Please submit a GitHub issue or contact me directly. Some general properties Publish? Almost every component has this property. If Publish? is false, ie. the checkbox is not checked, the content is only visible by writers and administrators. url Every url must be unique. It only accepts letters, numbers, - , and _ . name Every name must be unique. It only accepts letters, numbers, space, - and _ . Category The names of the categories are unique. Tutorial Anchor The tutorial anchor is a weird concept. Every anchor stores the url and the name of a tutorial. It's linked with content in different languages. So, when you want to create a brand new tutorial, that is, not a translation of an existing tutorial, you have to create an anchor first. The name of this anchor should be english name of the tutorial. And the url should be the name except every space is replaced by - . You can't delete an anchor when there are content associated with it. You have to delete all the content manually first before deleting the anchor. Tutorial anchor now contains rank field. The rank field is built from two numbers: level and section . The level , a three-digit number, indicates how hard the tutorial is. The first digit is the difficulty level and the rest two digits serve as the index within the course level. Say 403 , which is a 400 level course and is probably the third one in the 400 level courses. The section number is a number from 0 to 9 (for now). 0 means the current tutorial is the only tutorial related to the topic discussed in the tutorial. The section should be consecutive, meaning if the section is set to n , there should already be n-1 tutorials in the related topic. And each of the existing tutorial should take one number from 1 to n-1 . Some conventions should be followed during choosing the rank . The index should be set as far apart as possible to accommodate potential future tutorials. The section number should follow the guideline mentioned in the previous paragraph. To accommodate the rank field, the name and the url of the tutorial anchors related to the same topic should follow additional conventions. The names should start with the related topic, and the rest of name should the specific part discussed in individual tutorials. Say we can have Shortest Path: Dijkstra's Algorithm and Shortest Path: \u200eBellman\u2013Ford Algorithm . Tutorial Content In tutorial content page, on the top of the table, a language selector is present. You can use that to navigate to a specific language and the table will load up the tutorial content in that language. The default is loaded to the current language of the user interface. If the tutorial content is not added to the database, a <None> label is presented. By clicking on the <None> label, you are creating new content. There is not Add New button because every content is associated with an anchor and you can't create new content without attaching to an existing anchor. By clicking on other labels, you are modifying an existing content. IMPORTANT: about how to use content editor The content editor is loaded up to markdown library I found on Github. The functions don't quite fit in the application of this web app so I will write a custom editor in the future which should enable wordpress-like editing experience. So for now, writers should write there tutorials on a local document. And then copy paste it to the webpage. Uploading static files is a little bit inconvenient since it's separated process, but that's what I can do for now. You should use Uplaods page to upload static files and copy the relative link to the editor. Relative link is recommended and you should always use relative link. Every uploaded file will be available on https://root_url/year/month/filename , in this case https://graphery.reedcompbio.org/year/month/filename . It's writers duty to make sure the file name is not duplicated. The abstract box in the tutorial content will be rendered as html, so you can put either plain text or html there. Graph In the graph editor, the can also see a url input and a name input. The same guideline from tutorial content editing should be applied here. You can paste the graph json to the text area or you can use the uploader below the text area to upload a json file and load the content of that file by clicking the paper plane on the right. You can use bundle module in the git repo to generate a very basic graph json. from bundle.GraphObjects.Node import Node from bundle.GraphObjects.Edge import Edge from bundle.GraphObjects.MutableGraph import MutableGraph graph : MutableGraph = MutableGraph () node_0 : Node = graph . add_node ( identity = 'node_name' ) node_1 : Node = graph . add_node ( identity = 'distinct_node_name' ) edge_0 : Edge = graph . add_edge ( identity = 'edge_1' , ()) # you can use `remove_node` or `remove_edge` to remove components from a graph object. # api will be listed in future update print ( graph . generate_json ()) Graph Info Nothing special about it. The IMPORTANT note in tutorial content section also applies here. Code The code editor actually smashes two editors together. The top section is the actual code editor where you can paste the code and submit it. The second section is the result json generator. Since the server side generator is not complete yet, you can only use a local generator, whose usage can be found in a separated page . One tutorial only has one page and you can only execute code on the graphs associated with that tutorial. If you can't see the graph you want, please go to either the graph editor or the tutorial editor and link the graph and the tutorial together and then go back to generate results. You HAVE TO submit your code first before generating any result json. There are two submit buttons for two section so MAKE SURE you saved both sections before exiting. The code content should have the following components: tracer and graph_object from dummy_graph. tracer is the module that generates debug result. graph_object from dummy_graph is used to mount graph pulled from database during execution. You can't execute the code without these two components. main function is also required, it's the entry point. Without it, the code can't be parsed. tracer should be applied to every function which contains the variable you want to trance. If you don't specify depth param, and only apply tracer on the main function, other variables outside of main with NOT be traced. from bundle.seeker import tracer from bundle.utils.dummy_graph import graph_object @tracer ( 'b' ) def a (): b = 10 print ( b ) def main (): a ()","title":"Get Started"},{"location":"for-writers/get-started/#get-started-for-writers","text":"","title":"Get Started For Writers"},{"location":"for-writers/get-started/#introduction","text":"This is a guide for people who want to contribute tutorials.","title":"Introduction"},{"location":"for-writers/get-started/#components","text":"A tutorial consists of the following components: categories, a tutorial anchor, tutorial content in different languages, a graph anchor, graph info in different languages, code content, and execution results.","title":"Components"},{"location":"for-writers/get-started/#add-delete-and-modify","text":"Every component can be created in the control panel. Simply by directing to the component page and clicking on Add New button, the app will take you to a empty page where you can fill in content and save it to the cloud. To delete an entry, click on the red trashcan button at the end of the table, confirm that you know what you are doing in a popup, and the entry should be removed from the database. All deletion is NOT reversible for now. So please be cautious about the delete buttons. Deleting uploads is an exception. You need to click on the upload you want to delete. And you can find the a Delete PERMANENTLY button on a popup. Deleting tutorial anchors and graphs is another exception, which will be described in the following sections. To modify an existing entry, click on the fist cell corresponding to the entry you want to delete, the app will take you to an editing page. Changes are saved only by clicking on the Submit buttons. A green popup will follow every successful save. If you don't see one, there is a chance the content is not saved. Please save the content locally on your computer and contact me if you encounter this situation. Every unsaved changes will be discarded when you leave the page. There will be a confirm popup so don't worry about hitting go back button by accident.","title":"Add, Delete, and Modify"},{"location":"for-writers/get-started/#about-the-structure-of-the-control-panel","text":"Every thing on the control panel table is NOT editable. You have use corresponding editor page to edit content. Every action that involves with the server (or database) will return a status popup, usually on the bottom of the window. If you did something and nothing happened on the page, that means there are some glitches on the server. Please submit a GitHub issue or contact me directly.","title":"About the structure of the control panel"},{"location":"for-writers/get-started/#some-general-properties","text":"Publish? Almost every component has this property. If Publish? is false, ie. the checkbox is not checked, the content is only visible by writers and administrators. url Every url must be unique. It only accepts letters, numbers, - , and _ . name Every name must be unique. It only accepts letters, numbers, space, - and _ .","title":"Some general properties"},{"location":"for-writers/get-started/#category","text":"The names of the categories are unique.","title":"Category"},{"location":"for-writers/get-started/#tutorial-anchor","text":"The tutorial anchor is a weird concept. Every anchor stores the url and the name of a tutorial. It's linked with content in different languages. So, when you want to create a brand new tutorial, that is, not a translation of an existing tutorial, you have to create an anchor first. The name of this anchor should be english name of the tutorial. And the url should be the name except every space is replaced by - . You can't delete an anchor when there are content associated with it. You have to delete all the content manually first before deleting the anchor. Tutorial anchor now contains rank field. The rank field is built from two numbers: level and section . The level , a three-digit number, indicates how hard the tutorial is. The first digit is the difficulty level and the rest two digits serve as the index within the course level. Say 403 , which is a 400 level course and is probably the third one in the 400 level courses. The section number is a number from 0 to 9 (for now). 0 means the current tutorial is the only tutorial related to the topic discussed in the tutorial. The section should be consecutive, meaning if the section is set to n , there should already be n-1 tutorials in the related topic. And each of the existing tutorial should take one number from 1 to n-1 . Some conventions should be followed during choosing the rank . The index should be set as far apart as possible to accommodate potential future tutorials. The section number should follow the guideline mentioned in the previous paragraph. To accommodate the rank field, the name and the url of the tutorial anchors related to the same topic should follow additional conventions. The names should start with the related topic, and the rest of name should the specific part discussed in individual tutorials. Say we can have Shortest Path: Dijkstra's Algorithm and Shortest Path: \u200eBellman\u2013Ford Algorithm .","title":"Tutorial Anchor"},{"location":"for-writers/get-started/#tutorial-content","text":"In tutorial content page, on the top of the table, a language selector is present. You can use that to navigate to a specific language and the table will load up the tutorial content in that language. The default is loaded to the current language of the user interface. If the tutorial content is not added to the database, a <None> label is presented. By clicking on the <None> label, you are creating new content. There is not Add New button because every content is associated with an anchor and you can't create new content without attaching to an existing anchor. By clicking on other labels, you are modifying an existing content. IMPORTANT: about how to use content editor The content editor is loaded up to markdown library I found on Github. The functions don't quite fit in the application of this web app so I will write a custom editor in the future which should enable wordpress-like editing experience. So for now, writers should write there tutorials on a local document. And then copy paste it to the webpage. Uploading static files is a little bit inconvenient since it's separated process, but that's what I can do for now. You should use Uplaods page to upload static files and copy the relative link to the editor. Relative link is recommended and you should always use relative link. Every uploaded file will be available on https://root_url/year/month/filename , in this case https://graphery.reedcompbio.org/year/month/filename . It's writers duty to make sure the file name is not duplicated. The abstract box in the tutorial content will be rendered as html, so you can put either plain text or html there.","title":"Tutorial Content"},{"location":"for-writers/get-started/#graph","text":"In the graph editor, the can also see a url input and a name input. The same guideline from tutorial content editing should be applied here. You can paste the graph json to the text area or you can use the uploader below the text area to upload a json file and load the content of that file by clicking the paper plane on the right. You can use bundle module in the git repo to generate a very basic graph json. from bundle.GraphObjects.Node import Node from bundle.GraphObjects.Edge import Edge from bundle.GraphObjects.MutableGraph import MutableGraph graph : MutableGraph = MutableGraph () node_0 : Node = graph . add_node ( identity = 'node_name' ) node_1 : Node = graph . add_node ( identity = 'distinct_node_name' ) edge_0 : Edge = graph . add_edge ( identity = 'edge_1' , ()) # you can use `remove_node` or `remove_edge` to remove components from a graph object. # api will be listed in future update print ( graph . generate_json ())","title":"Graph"},{"location":"for-writers/get-started/#graph-info","text":"Nothing special about it. The IMPORTANT note in tutorial content section also applies here.","title":"Graph Info"},{"location":"for-writers/get-started/#code","text":"The code editor actually smashes two editors together. The top section is the actual code editor where you can paste the code and submit it. The second section is the result json generator. Since the server side generator is not complete yet, you can only use a local generator, whose usage can be found in a separated page . One tutorial only has one page and you can only execute code on the graphs associated with that tutorial. If you can't see the graph you want, please go to either the graph editor or the tutorial editor and link the graph and the tutorial together and then go back to generate results. You HAVE TO submit your code first before generating any result json. There are two submit buttons for two section so MAKE SURE you saved both sections before exiting. The code content should have the following components: tracer and graph_object from dummy_graph. tracer is the module that generates debug result. graph_object from dummy_graph is used to mount graph pulled from database during execution. You can't execute the code without these two components. main function is also required, it's the entry point. Without it, the code can't be parsed. tracer should be applied to every function which contains the variable you want to trance. If you don't specify depth param, and only apply tracer on the main function, other variables outside of main with NOT be traced. from bundle.seeker import tracer from bundle.utils.dummy_graph import graph_object @tracer ( 'b' ) def a (): b = 10 print ( b ) def main (): a ()","title":"Code"},{"location":"user-manual/get-started/","text":"Get Started Introduction The get stated section is intended for writers who want to prepare their codes for tutorials. Graph Objects There are several main building blocks for a graph: Node , NodeSet , Edge , EdgeSet , Graph . In this section, we will go over these concepts. Node Every Node object has a unique id and a name. When the name of a node is not specified specifically, it is filled with it's id and a prefix. For Node , the default prefix is n . So the name of a node with id 1 is n1 . Two Node instances are equal if and only if their ids are equal. Every Node instance has a properties field that collects the properties of the instance. The properties will be displayed in a tooltip once your mouse curser is hovered on the node. Some magic methods are overridden so that you can use the basic operators like == and != . The equality follows the rules above. # assume n1 and n2 are Node instances n1 == n2 # if the id of n1 is equal to that of n2 n1 != n2 # the negation of equality above n1 > n2 # if the id of n1 is bigger than n2 n1 < n2 # if the id of n1 is smaller than n2 n1 >= n2 n1 <= n2 The representation string of a Node object is Node(id: the_node_id) . NodeSet NodeSet describes a set of nodes. The elements in the set are unique. It is also not editable (for now). You can also use python native operators to get the relationships between Node and NodeSet . # assume n1, n2, and n3 are Node instances; node_set is a NodeSet instance # the ids of the three nodes are 1, 2, 3 respectively # also, n1 and n3 are in node_set while n2 is not len ( node_set ) == 2 # evaluated True node_set [ 1 ] == n1 # evaluated True n3 in node_set # evaluated True n2 not in node_set # evaluated True for node in node_set : print ( node ) # this will print Node(id: 1) and Node(id: 3) # on separated lines print ( node_set ) # print out [Node(id: 1), Node(id: 3) Edge Edge is like Node since every instance of Edge has a id and name . The same rules described above are also applied to Edge . The properties field is also present in Edge . It can be accessed using the same method. An additional field in an Edge instance is directed , which indicates whether the edge is directed. Naturally, instances of Edge also support native python operators. But there are more in Edge . # assuming n1, n2 and n3 are Node instances # e1 is an Edge instance which is from n1 to n2 n1 in e1 # evaluated True n3 in e1 # evaluated False for node in edge : print ( node ) # this will print Node(id: 1) and Node(id: 2) len ( e1 ) # is equal to 2 and does not make sense at all The representation string of a Edge object is Edge(id: the_edge_id) EdgeSet The EdgeSet is similar to NodeSet . All the operators are supported. Graph The a Graph instance has a node set and an edge set which are represented by NodeSet and EdgeSet . You can access the node set by calling graph.nodes or graph.V assuming graph is a Graph instance. Similarly, the edge set can be accessed by graph.edges or graph.E . # assuming n1, n2, n3, and n4 are nodes in a graph named g1 # e1, e2, e3 are edges n1 in g1 # evaluated True e1 in g1 # evaluated True g1 . empty () # evaluated False since the graph is not empty File conventions The files you submit to the backend must contain a entry.py file. The backend will import entry.py and select functions with special prefix and postfix to run tracer on. The files can contain other python files and files other file python source format that may severs as data preparations, etc. But the backend will not import those files. You need to explicit append @tracer() to the functions and supply a list of variables which you want to trace.","title":"Get Started"},{"location":"user-manual/get-started/#get-started","text":"","title":"Get Started"},{"location":"user-manual/get-started/#introduction","text":"The get stated section is intended for writers who want to prepare their codes for tutorials.","title":"Introduction"},{"location":"user-manual/get-started/#graph-objects","text":"There are several main building blocks for a graph: Node , NodeSet , Edge , EdgeSet , Graph . In this section, we will go over these concepts.","title":"Graph Objects"},{"location":"user-manual/get-started/#node","text":"Every Node object has a unique id and a name. When the name of a node is not specified specifically, it is filled with it's id and a prefix. For Node , the default prefix is n . So the name of a node with id 1 is n1 . Two Node instances are equal if and only if their ids are equal. Every Node instance has a properties field that collects the properties of the instance. The properties will be displayed in a tooltip once your mouse curser is hovered on the node. Some magic methods are overridden so that you can use the basic operators like == and != . The equality follows the rules above. # assume n1 and n2 are Node instances n1 == n2 # if the id of n1 is equal to that of n2 n1 != n2 # the negation of equality above n1 > n2 # if the id of n1 is bigger than n2 n1 < n2 # if the id of n1 is smaller than n2 n1 >= n2 n1 <= n2 The representation string of a Node object is Node(id: the_node_id) .","title":"Node"},{"location":"user-manual/get-started/#nodeset","text":"NodeSet describes a set of nodes. The elements in the set are unique. It is also not editable (for now). You can also use python native operators to get the relationships between Node and NodeSet . # assume n1, n2, and n3 are Node instances; node_set is a NodeSet instance # the ids of the three nodes are 1, 2, 3 respectively # also, n1 and n3 are in node_set while n2 is not len ( node_set ) == 2 # evaluated True node_set [ 1 ] == n1 # evaluated True n3 in node_set # evaluated True n2 not in node_set # evaluated True for node in node_set : print ( node ) # this will print Node(id: 1) and Node(id: 3) # on separated lines print ( node_set ) # print out [Node(id: 1), Node(id: 3)","title":"NodeSet"},{"location":"user-manual/get-started/#edge","text":"Edge is like Node since every instance of Edge has a id and name . The same rules described above are also applied to Edge . The properties field is also present in Edge . It can be accessed using the same method. An additional field in an Edge instance is directed , which indicates whether the edge is directed. Naturally, instances of Edge also support native python operators. But there are more in Edge . # assuming n1, n2 and n3 are Node instances # e1 is an Edge instance which is from n1 to n2 n1 in e1 # evaluated True n3 in e1 # evaluated False for node in edge : print ( node ) # this will print Node(id: 1) and Node(id: 2) len ( e1 ) # is equal to 2 and does not make sense at all The representation string of a Edge object is Edge(id: the_edge_id)","title":"Edge"},{"location":"user-manual/get-started/#edgeset","text":"The EdgeSet is similar to NodeSet . All the operators are supported.","title":"EdgeSet"},{"location":"user-manual/get-started/#graph","text":"The a Graph instance has a node set and an edge set which are represented by NodeSet and EdgeSet . You can access the node set by calling graph.nodes or graph.V assuming graph is a Graph instance. Similarly, the edge set can be accessed by graph.edges or graph.E . # assuming n1, n2, n3, and n4 are nodes in a graph named g1 # e1, e2, e3 are edges n1 in g1 # evaluated True e1 in g1 # evaluated True g1 . empty () # evaluated False since the graph is not empty","title":"Graph"},{"location":"user-manual/get-started/#file-conventions","text":"The files you submit to the backend must contain a entry.py file. The backend will import entry.py and select functions with special prefix and postfix to run tracer on. The files can contain other python files and files other file python source format that may severs as data preparations, etc. But the backend will not import those files. You need to explicit append @tracer() to the functions and supply a list of variables which you want to trace.","title":"File conventions"},{"location":"user-manual/local-server/","text":"Local Server Introduction Local server is used to generate step by step debug info for the front end. Please check out utils before reading this. Install Go the release page , and download the user_server.zip file. Extract everything in the zip file to a folder. Or you can clone the repository if the version is not available on the release page: bash git clone https://github.com/FlickerSoul/Graphery.git cd Graphery/backend Under this director, you can see a bundle folder and a user_server.py file. Those two will be the only thing you need. You can copy them in to a separate folder and delete the rest. Usage No dependencies required. If you are a Unix user, please click on the launch file. If you are a Windows user, please click on the launch.bat file. You can also manually launch the server in a terminal if the script doesn't work. Python 3.7 and above is required to run this server. Check you python version using the following command first. bash python --version Then run under the folder which contains bundle and user_server.py bash python user_server.py More The execution log file are located in ~/.graphery_cache/log/graphery_controller_execution.log . If you want the controller to output the log on the terminal, you can type the following shell command to your terminal: export SEEKER_LOG_OUTPUT_FLAG = 0 If you also want to turn off the on-screen output, you also need the following shell command: export SEEKER_DEFAULT_OUTPUT_FLAG = 0","title":"Local Server"},{"location":"user-manual/local-server/#local-server","text":"","title":"Local Server"},{"location":"user-manual/local-server/#introduction","text":"Local server is used to generate step by step debug info for the front end. Please check out utils before reading this.","title":"Introduction"},{"location":"user-manual/local-server/#install","text":"Go the release page , and download the user_server.zip file. Extract everything in the zip file to a folder. Or you can clone the repository if the version is not available on the release page: bash git clone https://github.com/FlickerSoul/Graphery.git cd Graphery/backend Under this director, you can see a bundle folder and a user_server.py file. Those two will be the only thing you need. You can copy them in to a separate folder and delete the rest.","title":"Install"},{"location":"user-manual/local-server/#usage","text":"No dependencies required. If you are a Unix user, please click on the launch file. If you are a Windows user, please click on the launch.bat file. You can also manually launch the server in a terminal if the script doesn't work. Python 3.7 and above is required to run this server. Check you python version using the following command first. bash python --version Then run under the folder which contains bundle and user_server.py bash python user_server.py","title":"Usage"},{"location":"user-manual/local-server/#more","text":"The execution log file are located in ~/.graphery_cache/log/graphery_controller_execution.log . If you want the controller to output the log on the terminal, you can type the following shell command to your terminal: export SEEKER_LOG_OUTPUT_FLAG = 0 If you also want to turn off the on-screen output, you also need the following shell command: export SEEKER_DEFAULT_OUTPUT_FLAG = 0","title":"More"},{"location":"user-manual/utils/","text":"Utilities Introduction This article talks about how the backend prepares data for database from user-input files. All the utilities live in the bundle module. There are three sections: GraphObjects in which all the elements of graphs are defined, seeker the variable tracing module, and utils which contains helpers used by controller . controller.py contains controller which should be the entry point of other utilities. GraphObjects The APIs exposed by GraphObject are listed here . This section is for developers who wants to generate graph objects. Graph.py has a function called graph_generator , which takes in a json string in cyjs format which is described in the following example. { \"elements\" :{ \"nodes\" :[ { \"data\" :{ \"id\" : \"a\" } }, { \"data\" :{ \"id\" : \"b\" } } ], \"edges\" :[ { \"data\" :{ \"id\" : \"ab\" , \"source\" : \"a\" , \"target\" : \"b\" } } ] }, \"layout\" :{ \"name\" : \"dagre\" , }, \"style\" :[ { \"selector\" : \"node\" , \"style\" :{ \"label\" : \"data(id)\" } } ] } The JSON content must contain elements . There is a default global layout added to the style section. If you want to specify the layout engine, please change the name of the layout. The available layout engines are dagre // used for directed acycle graphs fcose // https://github.com/iVis-at-Bilkent/cytoscape.js-fcose preset // predefined layout => does not apply any layout engine random // random layout The cyjs format is extended in this module. You can create an object filed displayed in a node or an edge element, like this: \"nodes\" : [ { \"data\" : { \"id\" : 1 }, \"displayed\" : { \"degree\" : 0 } } ] All the fields in displayed will be recorded into the properties field in corresponding Node or Edge object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling node[filed_name] for example, node['degree'] . We will provide tools for adding displayed section since it's not provided by Cytoscape software. The feature is coming soon. controller The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the Recorder and Processor which we will go into later. Before going into its usage, we need to talk about TempSysPathAdder . TempSysPathAdder exists in bundle.utils.cache_file_helpers . It takes in a Path object or a string of path and add the path to system path so that the code after it can use __import__ to import the python code in that path and use it directly as a module. The following code is an example: from bundle.controller import controller from bundle.utils.cache_file_helpers import TempSysPathAdder from importlib import import_module with controller as folder_creator , \\ folder_creator ( 'cache_folder_name' ) as cache_folder , \\ TempSysPathAdder ( cache_folder ): # create file in the temp_dir and import it directly copy_file_to_temp_folder ( '/path/to/python_code' ) imported_module = import_module ( 'module_name' ) seeker The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called seeker . It is modified from PySnooper created by Ram Rachum . Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code. tracer can be imported from bundle.seeker and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example: from bundle.seeker import tracer @tracer ( watch = [ 'x' , 'y' ]) def black_box ( x , y ): x *= y y *= x return x + y And you can specify a watch list by the keyword watch . The watch list should contain strings of variables' names, like x , y , object.element , and seq[index] . Recorder and Processor The tracer needs a Recorder instance to be functional since the main function of this module is to record changes. If you are using controller , the Recorder creation and reset if managed by it (or tracer will create a Recorder instance by itself since the prerequisite is recorder not being empty). A Recorder instance maintains a changes list. Each element is a mapping that contains three fields: line , variables , and accesses . The line field represents the current line. variabels records the variable changed in this line. accesses records the accessed attributes like a variable in an object. With these data generated after running tracer , it's Processor instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).","title":"Utilities"},{"location":"user-manual/utils/#utilities","text":"","title":"Utilities"},{"location":"user-manual/utils/#introduction","text":"This article talks about how the backend prepares data for database from user-input files. All the utilities live in the bundle module. There are three sections: GraphObjects in which all the elements of graphs are defined, seeker the variable tracing module, and utils which contains helpers used by controller . controller.py contains controller which should be the entry point of other utilities.","title":"Introduction"},{"location":"user-manual/utils/#graphobjects","text":"The APIs exposed by GraphObject are listed here . This section is for developers who wants to generate graph objects. Graph.py has a function called graph_generator , which takes in a json string in cyjs format which is described in the following example. { \"elements\" :{ \"nodes\" :[ { \"data\" :{ \"id\" : \"a\" } }, { \"data\" :{ \"id\" : \"b\" } } ], \"edges\" :[ { \"data\" :{ \"id\" : \"ab\" , \"source\" : \"a\" , \"target\" : \"b\" } } ] }, \"layout\" :{ \"name\" : \"dagre\" , }, \"style\" :[ { \"selector\" : \"node\" , \"style\" :{ \"label\" : \"data(id)\" } } ] } The JSON content must contain elements . There is a default global layout added to the style section. If you want to specify the layout engine, please change the name of the layout. The available layout engines are dagre // used for directed acycle graphs fcose // https://github.com/iVis-at-Bilkent/cytoscape.js-fcose preset // predefined layout => does not apply any layout engine random // random layout The cyjs format is extended in this module. You can create an object filed displayed in a node or an edge element, like this: \"nodes\" : [ { \"data\" : { \"id\" : 1 }, \"displayed\" : { \"degree\" : 0 } } ] All the fields in displayed will be recorded into the properties field in corresponding Node or Edge object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling node[filed_name] for example, node['degree'] . We will provide tools for adding displayed section since it's not provided by Cytoscape software. The feature is coming soon.","title":"GraphObjects"},{"location":"user-manual/utils/#controller","text":"The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the Recorder and Processor which we will go into later. Before going into its usage, we need to talk about TempSysPathAdder . TempSysPathAdder exists in bundle.utils.cache_file_helpers . It takes in a Path object or a string of path and add the path to system path so that the code after it can use __import__ to import the python code in that path and use it directly as a module. The following code is an example: from bundle.controller import controller from bundle.utils.cache_file_helpers import TempSysPathAdder from importlib import import_module with controller as folder_creator , \\ folder_creator ( 'cache_folder_name' ) as cache_folder , \\ TempSysPathAdder ( cache_folder ): # create file in the temp_dir and import it directly copy_file_to_temp_folder ( '/path/to/python_code' ) imported_module = import_module ( 'module_name' )","title":"controller"},{"location":"user-manual/utils/#seeker","text":"The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called seeker . It is modified from PySnooper created by Ram Rachum . Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code. tracer can be imported from bundle.seeker and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example: from bundle.seeker import tracer @tracer ( watch = [ 'x' , 'y' ]) def black_box ( x , y ): x *= y y *= x return x + y And you can specify a watch list by the keyword watch . The watch list should contain strings of variables' names, like x , y , object.element , and seq[index] .","title":"seeker"},{"location":"user-manual/utils/#recorder-and-processor","text":"The tracer needs a Recorder instance to be functional since the main function of this module is to record changes. If you are using controller , the Recorder creation and reset if managed by it (or tracer will create a Recorder instance by itself since the prerequisite is recorder not being empty). A Recorder instance maintains a changes list. Each element is a mapping that contains three fields: line , variables , and accesses . The line field represents the current line. variabels records the variable changed in this line. accesses records the accessed attributes like a variable in an object. With these data generated after running tracer , it's Processor instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).","title":"Recorder and Processor"}]}